from typing import List

from igenerator import IGenerator
from model import Node, RootNode, MutiNode, ValueType, DataLeafNode, DataObjectNode, ImportNode
from parser_impl.json_template import jsonTemplate


# 是否是基础类型
def isBasicType(node: Node) -> bool:
    return node.type == ValueType.Double or \
           node.type == ValueType.String or \
           node.type == ValueType.Int or \
           node.type == ValueType.Bool


# 将蛇形转成驼峰形
def formatName(name: str):
    if name == '':
        return name

    formatName = ''
    items = name.split("_")
    for item in items:
        formatName += item[0].lower() + item[1:]
    return formatName


# 获取node对应的变量名称
def nodeName(node: Node) -> str:
    if isinstance(node, DataLeafNode) or isinstance(node, DataObjectNode):
        return node.alias if node.alias != '' else formatName(node.name)
    return ''


# 获取node对应的变量类型
def nodeToClass(node: Node) -> str:
    if node.type == ValueType.Double:
        return "double"

    if node.type == ValueType.Int:
        return "int"

    if node.type == ValueType.String:
        return "String"

    if node.type == ValueType.Bool:
        return "bool"

    if isinstance(node, RootNode):
        return node.cls

    if isinstance(node, DataObjectNode):
        if node.type == ValueType.Object:
            name = nodeName(node)
            cls = node.cls if node.cls != '' else name[0].upper() + name[1:]
            return cls

        # 获取数组中的元素类型
        if node.type == ValueType.Array:
            if node.cls != '':
                return node.cls

            if len(node.children) == 0:
                return "dynamic"

            if isBasicType(node.children[0]):
                return nodeToClass(node.children[0])

            name = nodeName(node)
            cls = name[0].upper() + name[1:] + "Item"
            return cls

    raise AttributeError("node to class failed, at line: " + node.source)


def nodeToClsArg(node: Node) -> str:
    if isinstance(node, DataLeafNode):
        name = nodeName(node)
        return nodeToClass(node) + " " + name + ";"

    if isinstance(node, DataObjectNode):
        name = nodeName(node)
        cls = nodeToClass(node)
        if node.type == ValueType.Array:
            cls = "List<{}>".format(cls)
        return cls + " " + name + ";"

    raise AttributeError("node to class arguments failed, at line: " + node.source)


def nodeToFromJson(node: Node) -> str:
    if isinstance(node, DataLeafNode):
        text = "{}: json['{}']".format(nodeName(node), node.name)
        if node.type == ValueType.Double and node.nullable:
            text += "?.toDouble()"
        text += ","
        return text

    if isinstance(node, DataObjectNode):
        json = "json['{}']".format(node.name)

        if node.type == ValueType.Object:
            text = "{0}.fromJson({1})".format(nodeToClass(node), json)
            if node.nullable:
                text = "{} != null ? {} : null".format(json, text)
            text = "{}: {},".format(nodeName(node), text)
            return text

        if node.type == ValueType.Array:
            text = "List<{}>.from({}.map((e) => e))".format(nodeToClass(node), json)
            if node.nullable:
                text = "{} != null ? {} : null".format(json, text)
            text = "{}: {},".format(nodeName(node), text)
            return text
    raise AttributeError("node to from json failed, at line: " + node.source)


def nodeToToJson(node: Node) -> str:
    if isinstance(node, DataLeafNode):
        text = r'"{}": {},'.format(node.name, nodeName(node))
        return text

    if isinstance(node, DataObjectNode):
        if node.type == ValueType.Object:
            text = "{}{}.toJson()".format(nodeName(node), "?" if node.nullable else "")
            text = r'"{}": {},'.format(node.name, text)
            return text

        if node.type == ValueType.Array:
            text = "List<dynamic>.from({}.map((e) => e))".format(nodeName(node))
            if node.nullable:
                text = "{} != null ? {} : null".format(nodeName(node), text)
            text = r'"{}": {},'.format(node.name, text)
            return text
    raise AttributeError("node to from json failed, at line: " + node.source)


generatorCodeHeader = """/*
  Don't edit.
  Code generated by jemo.py.
*/

import 'dart:convert';
"""

space = "    "

class JsonGenerator(IGenerator):
    _lineFeed = ''
    _createdClass = []
    _code = ''

    def __init__(self, linefeed: str):
        self._lineFeed = linefeed

    def generate(self, nodes: List[Node]) -> str:
        self._code = generatorCodeHeader
        for node in nodes:
            if isinstance(node, ImportNode):
                self._code += self._generateImportNode(node)
                continue
            self._code += self._generateNode(node)
        return self._code

    def _generateImportNode(self, node: ImportNode) -> str:
        importLibraries = "import '{}';{}".format(node.library, self._lineFeed)

        if node.child is not None:
            importLibraries += self._generateImportNode(node.child)

        return importLibraries

    def _generateNode(self, node: Node) -> str:
        if not isinstance(node, MutiNode):
            return ''

        cls = nodeToClass(node)

        if self._createdClass.__contains__(cls):
            return ''

        self._createdClass.append(cls)

        clsArgs = ''
        clsConstructionArgs = ''
        fromJson = ''
        toJson = ''
        superCls = "extends " + node.super + " " if isinstance(node, RootNode) else ""

        subNodes: List[DataObjectNode] = []

        for child in node.children:
            clsArgs += space + nodeToClsArg(child) + self._lineFeed
            clsConstructionArgs += "{}{}this.{},{}".format(space, space, nodeName(child), self._lineFeed)
            fromJson += "{}{}{}{}".format(space, space, nodeToFromJson(child), self._lineFeed)
            toJson += "{}{}{}{}".format(space, space, nodeToToJson(child), self._lineFeed)

            if isinstance(child, DataObjectNode):
                if child.type == ValueType.Array:
                    if len(child.children) == 0:
                        child.cls = "dynamic"
                    elif isBasicType(child.children[0]):
                        child.cls = nodeToClass(child.children[0])
                    else:
                        n = child.children[0]
                        if isinstance(n, DataObjectNode):
                            n.cls = nodeToClass(child)
                            subNodes.append(n)
                elif child.type == ValueType.Object:
                    subNodes.append(child)

        result = jsonTemplate.format(cls, clsArgs.rstrip(),
                                     clsConstructionArgs.rstrip(), fromJson.rstrip(),
                                     toJson.rstrip(), superCls)

        for child in subNodes:
            result += self._generateNode(child)

        return result
